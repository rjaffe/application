Architecture
============

The app layer is being developed through a test-driven agile approach, so don't expect a Gantt chart or a perfect
architecture diagram for a few months, as that's not how it works. 

The application layer is a war file. It finds a configuration which will be an xml file and is currently a properties
file. Bootstrapping is painful, but finding it on the classpath or as specified by a system property is likely, see
Config for the current approaches.

The main task of the app layer is to read that config and to interpret it so that it can serve configuration to the UI
and to the services and to make any inline crosswalking required in their communication.

State of Play
-------------

That said, here is the current state of play with the app layer architecture.

SVCAPP
......

svcapp is a nascent API which allows us to present a common name and operations system on the top of the services layer
which, underneath, marshalls the relevant operations. You will currently see it referred to as Storage.
That will change. This API will be CRUDALS, CRUD + Autocreate + List + Search. Autocreate is create but with a final
path part which is selected by the underlying layer, guaranteed unique; it's rather like createTmpFile() from the JRE,
but it's not restricted to temporary files. The API uses slash separate paths, and trades in JSON. Conversions are
done underneath and exactly what happens is up to the implementation: there are few invariants. eg Updating one "file"
could "alter" another, but we will adhere to the idea at least in spirit to the extent that the service layer allows
it. At the moment we've only got collection-object. Search is not currently even in the API, other operations work for
collectionobject. 

APPUI + Controller
..................

The controller will become more generic (and therefore smaller) as time goes on and we can drive more of it from our
config.

The idea is that we will have a similar api to SVCAPP at the top end for the UI integration. This will hide much of
the mess which is currently in the controller (so we've not singled out services for separation!). The controller
can be seen as a nascent implementation of the 

JXJ
...

XML/JSON converter. Largely complete (works for everything we need it to do). Driven by an XML file which describes
the conversion process in both directions, it has a simple API allowing interconversion bectween org.json objects and
dom4j xml. (See 'position' below for why).

Schema
......

At the moment the UI spec is stored on disc, and hidden in a package called schema. This will go when the XML based 
config is introduced in Hello Mars. The schema will be autogenerated from our config, and from calls into the svcapp
layer where appropriate. At this point our properties file will become an XML file (or many).

Confiurability
..............

The configurability code developed in two other codebases (xxu, toronto-1), and the plugins worked on in another (src)
have not been integrated yet. At the moment we're focussing on marshalling and structure.

Packages
........

org.collectionspace.chain.config           <- Bootstrap config. Looks in many places for info to start up
org.collectionspace.chain.controller       <- Webapp. Much will become APPUI
org.collectionspace.chain.schema           <- Stub for UISchema store. Moved into XML config for Mars
org.collectionspace.chain.storage          <- SVCAPP API (prototype)
org.collectionspace.chain.storage.file     <- Stub SVCAPP impl used in Hello, World
org.collectionspace.chain.storage.services <- SVCAPP impl for services (used in Hello, Moon onwards)
org.collectionspace.chain.util             <- Misc rubbish
org.collectionspace.chain.util.jpath       <- Used in JXJ: describes JSON path like XPath (part of jxj impl)
org.collectionspace.chain.util.jtmpl       <- Goldilocks templating for JSON (part of jxj impl)
org.collectionspace.chain.util.jxj         <- Goldilocks JSON/XML interconversion
org.collectionspace.chain.util.xtmpl       <- Goldilocks templating for XML (part of jxj impl)


Positions
---------

All subject to change, and presented with utmost humility, but it helps prevent us looking completely irrational, or
influenced by mysterious forces.

JSON and XML
............

Our current position on JSON and XML is this:

We prefer JSON in places where it's a long way from the user: in internal communication, between parts of the app, etc.
We prefer it here because it comes prestructured into text, arrays, maps, for easy manipulation, which is less unweildy
than DOM manipulations, and quicker for XPath. For this reason, we also like it in the critical path. That's why it
makes sense in the UI/App integration, and throughout the body of the app layer.

We prefer XML where it might be typed or read by users, either directly or some poor soul trying to implement a
services connection. We prefer it here because it's (marginally) easier to type and manipulate, and is generally
more human friend;y, at least with current tools. That's why it makes sense in the App config and in the App/Svc
integration which is an open wire-protocol.

This means that we will be inevitably translating between JSON and XML which we should be able to do easily. After
looking at existing tools (Mar 2009) we felt it necessary to write our on (see JXJ Position).

We use org.json throughout for JSON, but aren't particularly pleased with it. It is simple and non-magic though.

We use dom4j for XML, and quite like it. It minimises pointless DOM commands, and our XML is mainly off the 
critical path, so efficiency isn't as important.

JXJ
...

We reluctantly decided it was worth writing our own JSON/XML converter, because none quite fitted what we were after in
terms of complexity, which was at the goldilocks point. We were looking for a tool which allowed the generation of
quite complex XML (eg including namespaces, nesting tags) over which we didn't have (complete) control. However, we
didn't want a full transformation language as our XSLT experience suggests that there's a cutoff where programming
really is best done in a programming language. Sketching out the task made it seem small (and it was, we think), and
we could provide an incredibly simple API because we only needed it to do our one thing.

CSPACE-264/265 hack
...................

create will be marked unimplemented for collectionobject (use autocreate) as soon as CSPACE-265 is
resolved. For now there's a massive hack involving objectnumbers and othernumbers. This will all go very shortly: we
intend to use CSIDs exactly as intended, not to hide them.
